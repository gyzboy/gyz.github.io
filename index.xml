<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>十万个为什么</title>
    <link>https://gyzboy.github.io/</link>
    <description>Recent content on 十万个为什么</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Apr 2021 16:12:16 +0800</lastBuildDate><atom:link href="https://gyzboy.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JNI</title>
      <link>https://gyzboy.github.io/interview/android/jni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/jni/</guid>
      <description>JNI加载流程 JNI环境配置 CmakeList文件解析 JNI作用？ JNI中注册方法的方式? JNI访问java对象 JNI中字符串操作 JNI中的引用   JNI加载流程     Gradle调用外部构建脚本CMklist.txt CMake按照脚本中的命令将C++源文件native-lib.cpp编译成native-lib.so动态库,并把它编译到APK中 运行时首先加载native-lib.so,然后调用相应的native方法  JNI环境配置    在Gradle配置文件俩个地方配置externalNativeBuild {}，一个在defaultConfig里面一个在defaultConfig外面
 在defaultConfig外面的externalNativeBuild {}代码块用cmake制定了CMakeList.txt的路径 在defaultConfig里面的externalNativeBuild {}代码块用cmake主要是填写CMake命令参数  CmakeList文件解析     #配置加载头文件 include_directories(./src/main/cpp/include) file(GLOB main_src &amp;ldquo;src/main/cpp/*.cpp&amp;rdquo;) //定义main_src变量 add_library(native-lib SHARED native-lib.cpp) 可以定义多个库，CMake会构建他们，Gradle将自动把共享库打入APK中   第一个参数：设置这个库的名字 第二个参数：设置库的类型，SHARE 动态库.so后缀 ,STATIC 静态库 .a后缀 第三个参数：源文件的相对路径    find_library(log-lib log) 找到一个NDK库，并且把这个库的路径储存在一个变量中   第一个参数：变量名 第二个参数：使用的NDK原生库名称    target_link_libraries(native-lib ${log-lib})关联库，将指定的库关联起来   第一个参数：目标库 第二个参数：将目标库链接到日志库包含在NDK中。    set_target_properties(库名称 PROPERTIES IMPORTED_LOCATION ${CMAKE_SOURCE_DIR}/libs/${ANDROID_ABI}/xxx.</description>
    </item>
    
    <item>
      <title>事件处理</title>
      <link>https://gyzboy.github.io/interview/android/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>Q:如何捕获activity中的所有点击事件? Q:说说view中的事件分发? Q:如果我只想有view的拖拽事件，而不想要view的点击事件，让你重写这个view的拖拽怎么设计? Q:里面的view在onTouchEvent中消费，然后拖动手指，直到手指从其他他viewgroup上挪开手指 Q:view的onTouch和onTouchEvent事件的区别？ Q:view的onClick事件在什么时候触发的，和onTouch有什么区别? Q:事件是先到window的还是先到decorview的,为什么这样设计? Q:一个点击事件是如何从屏幕传递到view的? Q:MotionEvent是什么?有什么用? Q:ACTION_CANCEL是如何触发的? Q:几个监听Lisner动作回调的优先级是如何? Q:滑动冲突如何解决? Q:Activity的分发方法中调用了onUserInteraction()方法，你能说说这个方法有什么作用吗？ Q:ViewGroup是如何将多个手指产生的事件准确分发给不同的子view的？ Q:dispatchTouchEvent\onInterceptTouchEvent\onTouchEvent中各返回值处理   Q:如何捕获activity中的所有点击事件?     事件分发方案。通过重写Activity的dispatchTouchEvent方法，对页面上的点击事件进行拦截。但是拦截不到Dialog中的点击事件，因为事件分发由DecorView开始发起，但是Dialog所处的DecorView和Activity的DecorView不是同一个，所以无法在Activitiy的dispatchTouchEvent方法进行拦截Dialog中的点击事件。 hook替换OnClickListener方案。这个方案主要是通过替换View中的mOnClickListener为我们自己的OnClickListener，然后进行点击事件的拦截处理。但是这个方案需要获取替换的那个View才行，所以新增的View和Dialog都需要单独处理才行。新增的View需要进行当前页面的View树进行监听，Dialog必须对Dialog中的View再进行一次hook。 AspectJ切面编程方案。这个方案是在编译期将代码插入到目标方法中，所以只要找到切点——也就是View中的onClick方法即可。可以完美解决我们的问题，并且不需要用户另外操作。 无障碍服务方案。这个方案是通过Android中的无障碍服务，对APP中的所有点击事件进行拦截，对应的事件就是AccessibilityEvent.TYPE_VIEW_CLICKED。该方案也能完美解决我们的问题，但是有个很大的缺点，就是需要用户单独去设置页面开启该辅助服务才行。  Q:说说view中的事件分发?    ACTION_DOWN情况下:dispatchTouchEvent-&amp;gt;onIntercepterTouchEvenet-&amp;gt;onTouchEvent
Q:如果我只想有view的拖拽事件，而不想要view的点击事件，让你重写这个view的拖拽怎么设计?    onTouchEvent中return true
Q:里面的view在onTouchEvent中消费，然后拖动手指，直到手指从其他他viewgroup上挪开手指    一旦事件点击序列传到了view中,这个序列中的所有操作都交给这个view去处理
Q:view的onTouch和onTouchEvent事件的区别？    onTouch指setOnTouchListener的回调方法，它是优先于onTouchEvent事件的,如果onTouch方法返回true，是不会触发onTouchEvent事件的
Q:view的onClick事件在什么时候触发的，和onTouch有什么区别?    在onTouchEvent中的ACTION_UP中触发的,onTouch是在dispatchTouchEvent中触发的
Q:事件是先到window的还是先到decorview的,为什么这样设计?    这样设计是为了解耦，Activity只持有phonewindow,ViewRootImpl只持有decorview,phonewindow可以把事件分发到decorview
Q:一个点击事件是如何从屏幕传递到view的?    Q:MotionEvent是什么?有什么用?    一个MotionEvent对象内部使用一个数组来维护所有触控点的信息 UP/DOWN类型的事件包含了触控点索引，可以根据该索引做出对应的操作 触控点的索引是变化的，不能作为跟踪的依据，而必须依据触控点id</description>
    </item>
    
    <item>
      <title>动态化</title>
      <link>https://gyzboy.github.io/interview/android/%E5%8A%A8%E6%80%81%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E5%8A%A8%E6%80%81%E5%8C%96/</guid>
      <description>Q:Android与JS交互?  Android调用js代码 JS调用Android代码   Q:J2V8引擎 Q:一个JSRuntime如何区分多个js环境? Q:设计一个动态化框架需要考虑什么   Q:Android与JS交互?    Android调用js代码      通过WebView的loadUrl（）   //会触发页面刷新 mWebView.loadUrl(&amp;#34;javascript:callJS()&amp;#34;);   通过WebView的evaluateJavascript（）   //不会触发界面刷新,可以获取到返回结果 mWebView.evaluateJavascript（&amp;#34;javascript:callJS()&amp;#34;, new ValueCallback&amp;lt;String&amp;gt;() { @Override public void onReceiveValue(String value) { //此处为 js 返回的结果  } }); JS调用Android代码      通过WebView的addJavascriptInterface（）进行对象映射   //参数1：Javascript对象名 参数2：Java对象名 mWebView.addJavascriptInterface(new AndroidtoJs(), &amp;#34;test&amp;#34;);//AndroidtoJS类对象映射到js的test对象   通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息   Q:J2V8引擎    V8.</description>
    </item>
    
    <item>
      <title>插件化&amp;热修复</title>
      <link>https://gyzboy.github.io/interview/android/%E6%8F%92%E4%BB%B6%E5%8C%96%E7%83%AD%E4%BF%AE%E5%A4%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E6%8F%92%E4%BB%B6%E5%8C%96%E7%83%AD%E4%BF%AE%E5%A4%8D/</guid>
      <description>Q:Android中的ClassLoader? Q:Android中ClassLoader加载过程? Q:热修复方案? Q:插件化需要的技术 Q:Android打包流程   Q:Android中的ClassLoader?     系统类加载器  BootClassLoader  java实现,包访问修饰符   PathClassLoader  PathClassLoader来加载系统类和应用程序类  PathClassLoader通常用来加载已经安装的apk的dex文件（安装的apk的dex文件在/data/dalvik-cache)     DexClassLoader  DexClassLoader可以加载dex文件和包含dex文件的压缩文件（比如jar和apk文件），不管加载那种文件，最终都是加载dex文件  dexPath：dex相关文件的路径集合，多个文件用路径分割符分割，默认的文件分割符为 &amp;ldquo;:&amp;rdquo; optimizedDirectory:解压的dex文件储存的路径，这个路径必须是一个内部储存路径，一般情况下使用当钱应用程序的私有路径/data/data/Package Name/&amp;hellip; librarySearchPath:包含C++库的路径集合，多个路径用文件分割符分割，可以为null parent：父加载器       自定义加载器  Q:Android中ClassLoader加载过程?     新建DexPathList对象pathList 调用pathList.findClass  新建dexElements 遍历dexElements,调用element.findClass方法 获取DexFile对象dexFile,调用dexFile.findClass方法    Q:热修复方案?     底层替换方案  System.load：可以加载自定义路径下的so System.</description>
    </item>
    
    <item>
      <title>Activity</title>
      <link>https://gyzboy.github.io/interview/android/activity/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/activity/</guid>
      <description>Q:简述下Activity相关生命周期 Q:onStart调用后,用户就真正可以看见activity了吗? Q:Activity生命周期中,任务栈是怎么变化的 Q:onSaveInstance和onRestoreInstance的调用时机,系统会默认干些什么 Q:为什么不建议在onPause中处理耗时操作 Q:什么情况下activity会调用onPause Q:activity在onDestroy中做了什么？ Q:哪些是在activity清单文件配置中的必要元素,哪些是发布后不建议修改元素,为什么 Q:intent-filter过滤器是什么，有什么作用,其中各标签代表什么含义 Q:intent-filter是如何响应,然后启动activity的 Q:activity中的权限控制是怎么样的,详细解释下 Q:用户离开activity时,activity一定会被销毁吗？ Q:activity实例的销毁时机,系统会直接销毁activity吗 Q:setResult调用时机 Q:setResult可能会出现什么问题?如何解决？ Q:在有setResult时,activity的生命周期是什么样的? Q:activityA启动activityB时的生命周期?为什么要这样设计? Q:activity状态改变 Q:activity还有其他什么生命周期的函数,分别调用时机是什么时刻 Q:activity启动方式 Q:taskAffinity是做什么用的?有什么具体的应用场景? Q:如果一个A Activity（standard）启动B Activity（singleInstance），这个时候用户点击了手机最近访问列表，然后在再点击该App所在的界面（卡片），然后这个时候点击返回键,会发生什么?为什么? Q:任务，任务栈，前台任务栈，后台任务栈，返回栈分别是什么？ Q:有多少种操作activity任务堆栈的方式?操作的结果是什么？ Q:可以从后台启动activity吗?怎么做?   Q:在不同的生命周期内调用finish的生命周期是怎么样的? Q:finish调用后会立刻调用onStop、onDestroy吗？不会的话,为什么? Q:如果App还存在缓存进程，这个时候启动App，应用Application的onCreate方法会执行吗？ Q:启动一个Dialog,activity生命周期是如何变化的?为什么? Q:onSaveInstance是如何实现保持应用状态的?如果在里面传递大量数据会发生什么? Q:onResume执行了就可以认为界面对用户可见了?这种理解对吗? Q:一个activity从创建到用户可见,经历了什么操作,涉及到了哪些生命周期? Q:什么情况下startActivity需要设置Flag=NEW_TASK?为什么?不设置的话会发生什么? Q:activity从启动到显示,都经历了什么? Q:Activity、PhoneWindow、DecorView、ViewRootImpl之间的关系? Q:activity在屏幕旋转后如何保持下载不中断? Q:startActivities是干什么用的?activity栈是如何变化的? Q:Activity启动模式与FLAG结合? Q:Flag使用具体使用? Q:子线程可以startActivity吗?会有什么问题?   Q:简述下Activity相关生命周期    onCreate-&amp;gt;onRestart-&amp;gt;onStart-&amp;gt;onRestoreInstance-&amp;gt;onResume-&amp;gt;onPause-&amp;gt;onStop-&amp;gt;onRestrt-&amp;gt;onDestroy onSaveInstance onRestoreInstance
  onCreate:Activity生命周期的第一个方法，也是我们在android开发中接触的最多的生命周期方法。它本身的作用是进行Activity的一些初始化工作，比如使用setContentView加载布局，对一些控件和变量进行初始化等，此时activity还在后台,不可见
  onStart:对用户可见(这个可见指的是进程的可见),在此时包含activity进入前台与用户互动之前的最后准备工作
  onResume:系统会在 Activity 开始与用户互动之前调用此回调。此时，该 Activity 位于 Activity 堆栈的顶部，并会捕获所有用户输入</description>
    </item>
    
    <item>
      <title>android整体框架相关</title>
      <link>https://gyzboy.github.io/interview/android/%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6/</guid>
      <description>Q:进程与应用生命周期之间的关系 Q:系统是如何管理这些进程的? Q:activity启动中都涉及到了哪些类?分别有什么作用？ Q:一个Activity是如何启动的? Q:AMS，Zogyte，App进程，Launcher之间是如何通信的？ Q:为啥Activity启动流程中，大部分都是用Binder通讯，为啥跟Zygote通信的时候要用socket呢？ Q:Android启动流程? Q:ioctl是啥,android哪里用到了? Q:StartActivity的流程?哪里可以做的插件化? Q:startService的启动流程? Q:BindService是什么?为什么 bindService 能和 Activity 的生命周期联动? Q:sendBroadcast原理?什么时候回发生ANR? JobScheduler是什么?有什么用? Q:说说WorkManager Q:ANR有哪些场景会发生? Q:用MultiDex解决何事？其根本原因在于？Dex如何优化？主Dex放哪些东西？主Dex和其他Dex调用、关联？Odex优化点在于什么? Q:在打包过程中如何产生多个的DEX包？ Q:如果做到动态加载，怎么决定哪些DEX动态加载呢？ Q:如果启动后在工作线程中做动态加载，如果没有加载完而用户进行页面操作需要使用到动态加载DEX中的class怎么办？ Q:多渠道打包如何实现(Flavor、Dimension应用)？从母包生出渠道包实现方法？渠道标识替换原理？ Q:Android打包哪些类型文件不能混淆?   Q:进程与应用生命周期之间的关系     前台进程  它正在用户的互动屏幕上运行一个 Activity（其 onResume() 方法已被调用）。 它有一个 BroadcastReceiver 目前正在运行（其 BroadcastReceiver.onReceive() 方法正在执行）。 它有一个 Service 目前正在执行其某个回调（Service.onCreate()、Service.onStart() 或 Service.onDestroy()）中的代码。   可见进程  它正在运行的 Activity 在屏幕上对用户可见，但不在前台（其 onPause() 方法已被调用）。举例来说，如果前台 Activity 显示为一个对话框，而这个对话框允许在其后面看到上一个 Activity，则可能会出现这种情况。 它有一个 Service 正在通过 Service.startForeground()（要求系统将该服务视为用户知晓或基本上对用户可见的服务）作为前台服务运行。 系统正在使用其托管的服务实现用户知晓的特定功能，例如动态壁纸、输入法服务等。   服务进程  服务流程包含一个已使用 startService() 方法启动的 Service   缓存进程  目前不需要的进程,通常包含用户当前不可见的一个或多个 Activity 实例（onStop() 方法已被调用并返回）    Q:系统是如何管理这些进程的?</description>
    </item>
    
    <item>
      <title>C&#43;&#43;基础知识</title>
      <link>https://gyzboy.github.io/interview/c&#43;&#43;/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/c&#43;&#43;/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>什么是命名空间? 带默认形参的函数 函数模板 内联函数 类的定义 对象的建立和使用  对象创建 对象指针 对象引用   友元函数 虚基类和虚基类的使用 虚函数 文件读写 智能指针   什么是命名空间?    using namespace std;
类似于java中的包名,主要是为了解决多个模块间命名出冲突的问题
带默认形参的函数    int add(int a =4,int b =5){ return a+b; } cout &amp;lt;&amp;lt; add() &amp;lt;&amp;lt; endl; //9 函数模板    C++和java一样都有函数的重载，函数重载可以处理多种类型，同一个方法名，但依然需要分开定义，如果可以让他代码更精简一点，模板化就更好了,为此C++提供了函数模板这一机制，可以大大提高函数的通用性(自我感觉像泛型)
template&amp;lt;class 类型名1，class 类型名2…&amp;gt; 返回值 函数名（形参表列） 模板参数表 { 函数体 } 内联函数    通过在函数上添加inline关键字,在编译的时候，把函数代码插入到函数调用的地方， 就像普通的程序执行代码一样
类的定义    class Sts{ public://访问修饰符跟java类似  int a; char name[100]; int socre; int print(); };//注意这个分号 int Sts::print(){//在类外定义函数体，在类外定义函数体的需要类名加上::域限定符  cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34;/&amp;#34;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;#34;/&amp;#34;&amp;lt;&amp;lt;socre&amp;lt;&amp;lt;endl; return 0; } 对象的建立和使用    对象创建    int *a= new int;//动态分配一个int类型的内存空间； delete a;//释放内存； //分配10个int数据空间 int *aa= new int[10]; delete []aa; 对象指针    Sts *p; Sts s; s.</description>
    </item>
    
    <item>
      <title>ContentProvider</title>
      <link>https://gyzboy.github.io/interview/android/contentprovider/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/contentprovider/</guid>
      <description>  Q:介绍下FileProvider？   Q:介绍下FileProvider？    &amp;lt;!-- 配置FileProvider--&amp;gt; &amp;lt;provider android:name=&amp;#34;androidx.core.content.FileProvider&amp;#34; android:authorities=&amp;#34;${applicationId}.provider&amp;#34; android:exported=&amp;#34;false&amp;#34;//这里必须为false  android:grantUriPermissions=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;meta-data android:name=&amp;#34;android.support.FILE_PROVIDER_PATHS&amp;#34; android:resource=&amp;#34;@xml/provider_paths&amp;#34;/&amp;gt; &amp;lt;/provider&amp;gt; //provider_paths.xml &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;paths xmlns:android=&amp;#34;http://schemas.android.com/apk/res/android&amp;#34;&amp;gt; &amp;lt;external-path name=&amp;#34;external&amp;#34; path=&amp;#34;.&amp;#34;/&amp;gt; &amp;lt;/paths&amp;gt; </description>
    </item>
    
    <item>
      <title>GC</title>
      <link>https://gyzboy.github.io/interview/java/gc/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/gc/</guid>
      <description>  Q:垃圾收集算法? Q:如和判断一个对象是否存活?引用计数法和可达性算法哪个更加好？如何理解一个对象不一定会被回收？   Q:垃圾收集算法?     标记-清除:在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块 标记-整理:让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 复制:将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 分代收集:新生代使用：复制算法,老年代使用：标记 - 清除 或者 标记 - 整理 算法  Q:如和判断一个对象是否存活?引用计数法和可达性算法哪个更加好？如何理解一个对象不一定会被回收？       引用计数法   所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是“死对象”,将会被垃圾回收. 引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象A引用对象B，对象B又引用者对象A，那么此时A,B对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。   2.可达性算法(引用链法)  该算法的思想是：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。 在java中可以作为GC Roots的对象有以下几种:  虚拟机栈中引用的对象 方法区类静态属性引用的对象 方法区常量池引用的对象 本地方法栈JNI引用的对象     如何理解一个对象不一定会被回收？  虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一定会被回收。当一个对象不可达GC Root时，这个对象并不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 如果对象在可达性分析中没有与GCRoot的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。 如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。    </description>
    </item>
    
    <item>
      <title>Glide</title>
      <link>https://gyzboy.github.io/interview/android/glide/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/glide/</guid>
      <description>Q:Glide优势? Q:自己实现一个图片加载框架,需要考虑什么? Q:Glide中这几个点都是如何实现的? Q:Glide是如何加载动图的? Q:Glide中的缓存设计? Q:如何解决Glide缓存变化但图片没有更新问题?   Q:Glide优势?     多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video） 生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）   通过为每个activity或者Fragment创建一个无界面的SupportRequestManagerFragment来进行生命周期的绑定 在创建SupportRequestManagerFragment时会讲一个当前对象存储在map中,这是因为事务的提交commitAllowingStateLoss是post到队列中,防止重新创建fragment 在创建RequestManager时获取SupportRequestManagerFragment的Lifecycle对象    高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）   decodeFromWrappedStreams中会调用BitmapPool复用池,通过inBitmap获取复用图片    高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）  Q:自己实现一个图片加载框架,需要考虑什么?     异步加载：线程池 切换线程：Handler，没有争议吧 缓存：LruCache、DiskLruCache 防止OOM：软引用、LruCache、图片压缩、Bitmap像素存储位置 内存泄露：注意ImageView的正确引用，生命周期管理 列表滑动加载的问题：加载错乱、队满任务过多问题  Q:Glide中这几个点都是如何实现的?     异步加载  private GlideExecutor sourceExecutor; //加载源文件的线程池，包括网络加载  private GlideExecutor diskCacheExecutor; //加载硬盘缓存的线程池  ... private GlideExecutor animationExecutor; //动画线程池 Q:Glide是如何加载动图的?    从流里读取前3个字节用于判断是否为GIF图,确认为 GIF 动图后，会构建一个 GIF 的解码器（StandardGifDecoder），它可以从 GIF 动图中读取每一帧的数据并转换成 Bitmap，然后使用 Canvas 将 Bitmap 绘制到 ImageView 上，下一帧则利用 Handler 发送一个延迟消息实现连续播放，所有 Bitmap 绘制完成后又会重新循环，所以就实现了加载 GIF 动图的效果</description>
    </item>
    
    <item>
      <title>I/O</title>
      <link>https://gyzboy.github.io/interview/java/io/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/io/</guid>
      <description>  Q:Java中的I/O可以分为几类? Q:NIO和普通I/O区别? Q:字符流和字节流有什么区别？如何选择字节流或者字符流？什么是缓冲区，有什么作用？   Q:Java中的I/O可以分为几类?     磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO  Q:NIO和普通I/O区别?     NIO 是非阻塞的；只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义 NIO 面向块，I/O 面向流。  Q:字符流和字节流有什么区别？如何选择字节流或者字符流？什么是缓冲区，有什么作用？     区别:  字符流和字节流的使用非常相似，但是实际上字节流的操作不会经过缓冲区（内存）而是直接操作文本本身的，而字符流的操作会先经过缓冲区（内存）然后通过缓冲区再操作文件 字符流是对字节流的包装   如何选择字节流或者字符流？  字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的 如果是音频文件、图片、歌曲，就用字节流好点（避免数据丢失） 如果是关系到中文（文本）的，用字符流好点   什么是缓冲区，有什么作用？  缓冲区就是一段特殊的内存区域，很多情况下当程序需要频繁地操作一个资源（如文件或数据库）则性能会很低，所以为了提升性能就可以将一部分数据暂时读写到缓存区，以后直接从此区域中读写数据即可，这样就显著提升了性能。 对于 Java 字符流的操作都是在缓冲区操作的，所以如果我们想在字符流操作中主动将缓冲区刷新到文件则可以使用 flush() 方法操作    </description>
    </item>
    
    <item>
      <title>JS基础知识</title>
      <link>https://gyzboy.github.io/interview/js/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/js/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>Q:JS引擎线程的执行过程的三个阶段?  语法分析 预编译阶段 执行阶段   Q:变量提升的原因? Q:什么是闭包？ Q:什么是解构赋值? Q:yield关键字? Q:Promise函数? Q:Call&amp;amp;Apply方法 Q:await和async调用? Q:箭头函数   Q:JS引擎线程的执行过程的三个阶段?    语法分析    预编译阶段     js的运行环境
1.全局环境（JS代码加载完毕后，进入代码预编译即进入全局环境）
2.函数环境（函数调用执行时，进入该函数环境，不同的函数则函数环境不同)
3.eval（不建议使用，会有安全，性能等问题）
每进入一个不同的运行环境都会创建一个相应的执行上下文（Execution Context），那么在一段JS程序中一般都会创建多个执行上下文，js引擎会以栈的方式对这些执行上下文进行处理，形成函数调用栈（call stack），栈底永远是全局执行上下文（Global Execution Context），栈顶则永远是当前执行上下文。 函数调用栈   首次运行JS代码时，会创建一个全局执行上下文并Push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并Push到当前执行栈的栈顶。当栈顶函数运行完成后，其对应的函数执行上下文将会从执行栈中Pop出，上下文控制权将移到当前执行栈的下一个执行上下文。
 执行上下文的创建    创建变量对象（Variable Object） 建立作用域链（Scope Chain）:变量对象（Variable Object）转为活动对象（Active Object）   var num = 30; function test() { var a = 10; function innerTest() { var b = 20; return a + b } innerTest() } test() //innerTest的调用链  innerTestEC = { //变量对象  VO: {b: undefined}, //作用域链  scopeChain: [VO(innerTest), AO(test), AO(global)], //this指向  this: window }    确定this的指向    执行阶段      永远只有JS引擎线程在执行JS脚本程序 宏任务    同步任务指的是在JS引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。 异步任务指的是不直接进入JS引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进任务队列(task queue)，等待JS引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步Ajax，DOM事件，setTimeout等    事件循环    主线程执行栈 异步任务等待触发 任务队列    微任务:微任务（micro-task）的API主要有:Promise， process.</description>
    </item>
    
    <item>
      <title>JVM</title>
      <link>https://gyzboy.github.io/interview/java/jvm/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/jvm/</guid>
      <description>Q:jvm的内存模型是啥样的? Q:类的加载过程? Q:Class.forName() 和ClassLoader.loadClass()区别？实际开发你用那种，为什么？ Q:说一下对象的创建过程？变量创建过程种放在虚拟机哪里？ Q:什么情况下会触发类的初始化? Q:什么是双亲委派模型?有什么优势? Q:如何自定义一个类加载器? Q:如何使用自定义类加载器加载文件? Q:为什么会出现破坏双亲委派的模型？是解决了什么问题？ Q:基本数据类型一定存储在栈中吗？ Q:泛型是什么? Q:泛型通配符? Q:泛型擦除是什么?存在什么问题?有哪些补救方案?应用场景是哪些？ Q：泛型和反射有何联系？使用反射来获取泛型信息？getType和getGenericType有何区别？ Q:为什么说反射的效率低? Q:HashCode为什么使用31作为乘数? Q:static变量存储位置是哪里？静态变量的生命周期？静态变量何时销毁？静态引用的对象回收如何理解？ Q:什么是绑定？静态和动态绑定如何区别？动态绑定编译原理是什么？动态绑定运行原理是什么？ Q:Java内部类和静态内部类的区别 Q:为什么内部类调用的局部变量必须是final修饰的？局部变量对垃圾回收机制有什么样的影响？ Q:什么是多态?多态有哪些弊端？Java实现多态有哪些必要条件？什么是向上、向下转型? Q:常见代码块有哪些?执行顺序是什么样子的？ Q:带有类名.变量加载时,加载顺序是怎么样的? Q:Java数据类型有哪些？什么是值传递？什么是引用传递？如何理解值传递和引用传递，以及它们有何区别？   Q:java中方法参数的几种使用情况? Q:Java中对象存储   Q:jvm的内存模型是啥样的?     程序计数器:在jvm中，它就是程序控制流的指示器，循环，跳转，异常处理，线程的恢复等工作都需要依赖程序计数器去完成,此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemotyError情况的区域 虚拟机栈:在每个方法执行的时候，jvm都会同步创建一个栈帧去存储局部变量表，操作数栈，动态连接，方法返回值等信息。一个方法的生命周期就贯彻了一个栈帧从入栈到出栈的全部过程。局部变量表应该是我们接触的最多的，里面存储了java的8大基本数据类型（byte、short、char、int、float、long、double、boolean）、对象引用(reference类型，不是对象本身，是指向对象的引用)和returnAddress类型（指向一条字节码指令的地址）， 本地方法栈:native方法栈 堆:所有线程共享的一块内存区域，用于存放几乎所有的对象实例和数组，TLAB是线程私有的，在堆空间中分配，对象会首先存放在这个线程私有的TLAB中，可以提升线程分配的效率 方法区:方法区也是所有线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。运行时常量池就是方法区的一部分，代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用,Java语言并不要求常量一定只有编译期才能产生，也就是可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法  Q:类的加载过程?    加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，是依次有序的。但是解析阶段有可能会在初始化之后才会进行，这是为了支持java动态绑定的特性
 加载  通过一个类的全限定名获取定义此类的二进制字节流给了开发人员很大的灵活性,比如可以通过ZIP、网络、动态代理等技术加载指定二进制流   准备  正式为类变量（static变量）分配内存并设置初始值,此时变量所使用的内存，将在方法区分配,并且初始值为默认值    Q:Class.forName() 和ClassLoader.loadClass()区别？实际开发你用那种，为什么？     Class.forName() 和ClassLoader.loadClass()区别？  Class.</description>
    </item>
    
    <item>
      <title>LeakCanary</title>
      <link>https://gyzboy.github.io/interview/android/leakcanary/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/leakcanary/</guid>
      <description>Q:Java中各种引用类型?  强引用 软引用 弱引用 虚引用   如何通过引用队列判断是否发生内存泄漏? LeakCanary原理?   Q:Java中各种引用类型?    强引用      强引用是使用最普遍的引用。一个对象具有强引用，则在GC发生时，该对象将不会回收。当Jvm虚拟机内存空间不足时，虚拟机会抛出OutOfMemoryError错误，不会回收具有强引用的对象来解决内存不足的问题   软引用      当一个对象只有软引用，若虚拟机内存空间足够，垃圾回收器就不会回收该对象； 若内存空间不足，下次GC时这些只有软引用对象将被回收。若垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 在创建软引用实例时，可以传入一个引用队列（ReferenceQueue）将该软引用与引用队列关联，这样当软引用所引用的对象被垃圾回收器回收前，Jvm虚拟机会把这个软引用加入到与之关联的引用队列中   弱引用      弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在GC发生时，若一个对象只有弱引用，不管虚拟机内存空间是否足够，都会回收它的内存。 在创建弱引用实例时，可以传入一个引用队列（ReferenceQueue）将该软引用与引用队列关联，这样当软引用所引用的对象被垃圾回收器回收前，Jvm虚拟机就会把这个软引用加入到与之关联的引用队列中   虚引用      虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 在创建虚引用实例时，可以传入一个引用队列（ReferenceQueue）将该软引用与引用队列关联，这样当软引用所引用的对象被垃圾回收器回收前，Jvm虚拟机就会把这个软引用加入到与之关联的引用队列中   String str = new String(&amp;#34;abc&amp;#34;); ReferenceQueue queue = new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 PhantomReference pr = new PhantomReference(str, queue); 如何通过引用队列判断是否发生内存泄漏?</description>
    </item>
    
    <item>
      <title>OkHttp</title>
      <link>https://gyzboy.github.io/interview/android/okhttp/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/okhttp/</guid>
      <description>  Q:OkHttp中用到了哪些设计模式   Q:OkHttp中用到了哪些设计模式     外观模式。通过okHttpClient这个外观去实现内部各种功能。 建造者模式。构建不同的Request对象。 工厂模式。通过OkHttpClient生产出产品RealCall。 享元模式。通过线程池、连接池共享对象。 责任链模式。将不同功能的拦截器形成一个链。
 </description>
    </item>
    
    <item>
      <title>openGL</title>
      <link>https://gyzboy.github.io/interview/opengl/opengl/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/opengl/opengl/</guid>
      <description>基本概念  着色器 顶点着色器 片元着色器 坐标系 图形的绘制 投影 光照 纹理映射 渲染流程   绘制一个图形的步骤  1.绑定GLSurfaceView 2.创建shape并加载   变化矩阵   基本概念    着色器    着色器（Shader）是在GPU上运行的小程序
顶点着色器    把每个顶点在虚拟空间中的三维坐标变换为可以在屏幕上显示的二维坐标，并带有用于z-buffer的深度信息。顶点着色器可以操作的属性有：位置、颜色、纹理坐标，但是不能创建新的顶点
片元着色器    片元着色器计算每个像素的颜色和其它属性。它通过应用光照值、凹凸贴图，阴影，镜面高光，半透明等处理来计算像素的颜色并输出。它也可改变像素的深度(z-buffering)或在多个渲染目标被激活的状态下输出多种颜色。一个片元着色器不能产生复杂的效果，因为它只在一个像素上进行操作，而不知道场景的几何形状
坐标系    OpenGL ES采用的是右手坐标，选取屏幕中心为原点，从原点到屏幕边缘默认长度为1，也就是说默认情况下，从原点到（1,0,0）的距离和到（0,1,0）的距离在屏幕上展示的并不相同。即向右为X正轴方向，向左为X负轴方向，向上为Y轴正轴方向，向下为Y轴负轴方向，屏幕面垂直向上为Z轴正轴方向，垂直向下为Z轴负轴方向
图形的绘制    OpenGL ES2.0的世界里面只有点、线、三角形，其它更为复杂的几何形状都是由三角形构成的
投影    OpenGL ES中有两种投影方式：正交投影和透视投影。正交投影，物体不会随距离观测点的位置而大小发生变化。而透视投影，距离观测点越远，物体越小，距离观测点越近，物体越大
光照    光照由三种元素组成（也可以说是三种通道组成），分别为环境光、镜面光及散射光
 环境光是指从四面八方照射到物体上，其具体公式为：  环境光照射结果=材质反射系数∗环境光强度</description>
    </item>
    
    <item>
      <title>RecyclerView</title>
      <link>https://gyzboy.github.io/interview/android/recyclerview/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/recyclerview/</guid>
      <description>Q:RecyclerView中onLayout有哪些步骤流程? Q:RecyclerView中是如何获取ViewHolder的？有哪些步骤流程? Q:什么是pre-layout?什么时候调用? Q:stableID是什么？有什么作用? Q:什么是Scrap？设计思想是什么? Q:mChangedScrap 和 mAttachedScrap区别? Q:如何实现RecyclerView的拖拽排序? Q:当item超过一定数量，如何正确的设置RecyclerView的maxHeight？ Q:RecyclerView中的复用的几个问题 Q:RecyclerView回收些什么? Q:RecyclerView中的ViewHolder回收到哪里去? Q:什么情况下,会调用bindViewHolder? Q:RecyclerView卡片中持有的资源，到底该什么时候释放？ Q:RecyclerView中各级缓存的用途?各存储结构是什么样的? Q:如何设计一个RecyclerView的item点击事件? Q:RecyclerView的预加载是什么? Q:RecyclerView为什么进行预布局? Q:如何实现RecyclerView的局部更新，用过payload吗,notifyItemChange方法中的参数   Q:RecyclerView中onLayout有哪些步骤流程?    RecyclerView.onLayout(...) //布局放置 -&amp;gt;RecyclerView.dispatchLayout() //dispatchLayoutStep1方法等同于pre layout,预布局阶段,记录ViewHolder位置信息；;  -&amp;gt;RecyclerView.dispatchLayoutStep1() ///dispatchLayoutStep2方法处理真正布局的地方  -&amp;gt;RecyclerView.dispatchLayoutStep2() //开启动画阶段  -&amp;gt;RecyclerView.dispatchLayoutStep3() -&amp;gt;RecyclerView.dispatchLayoutStepX() //mLayout是LayoutManager的实例\  -&amp;gt;mLayout.onLayoutChildren(mRecycler, mState);\ //此处查看LinearLayoutManager.fill() 注释：填充给定Layout\  -&amp;gt;LinearLayoutManager.fill(recycler, mLayoutState, state, false);\ //循环调用，每次返回一个\  -&amp;gt;LinearLayoutManager.layoutChunk(recycler, layoutState) \ -&amp;gt;LinearLayoutManager.LayoutState.next()\ //通过 Recycler 获取指定位置的 ItemView\  -&amp;gt;RecyclerView.recycler.getViewForPosition(int position)\ //获取ViewHolder 返回ViewHolder中的ItemView,在这里决定是onCreateView还是bindView\  -&amp;gt;RecyclerView.tryGetViewHolderForPositionByDeadline(***) Q:RecyclerView中是如何获取ViewHolder的？有哪些步骤流程?</description>
    </item>
    
    <item>
      <title>View</title>
      <link>https://gyzboy.github.io/interview/android/view/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/view/</guid>
      <description>Q:View.getContext()一定会返回activity对象吗? Q:View.inflate和LayoutInflater.inflate方法区别？ Q:Inflate的三个参数(int resource, ViewGroup root, boolean attachToRoot),组合设置后分别有什么效果? Q:子线程中可以更新UI吗?为什么? Q:View坐标体系是什么? Q:为什么setTranslation会移动View的位置? Q:为什么View移动的位置跟mScrollX，mScrollY是相反的? Q:都有什么获取view区域的方法?怎么用? Q:View的绘制流程分几步，从哪开始？哪个过程结束以后能看到view？ Q:View什么时候发生绘制? Q:遍历ViewGroup中的View Q:ViewGroup有onMeasure方法吗？为什么? Q:setContentView之后发生了什么？ Q:setContentView可以在其他生命周期内执行吗?为什么? Q:view、drawable、bitmap之间的关系? Q:有了view，为什么还要设计drawable? Q:如何设计一个曝光系统?需要注意些什么? Q:有用过LayoutInflater.Factory吗？都有哪些应用场景? Q:如何计算一个Bitmap的内存空间,如何加载一张高清大图?一般的图片加载优化都有哪些手段? Q:一个viewGroup 绘制了4-5个view，当其中一个子view。例如背景变了。就会导致整个viewGroup的刷新。。请问有没有办法？仅仅只让对应的view更改UI。避免让viewGroup重新测量 绘制? Q:在绘制阶段，ViewGroup 不光要绘制自身，还需循环绘制其一众子 View，这个绘制策略默认为顺序绘制，即 [0 ~ childCount)。这个默认的策略，有办法调整吗？修改了之后，事件分发需要特殊处理吗？还是需要特殊处理?getChildAt会有相应变化吗? Q:通过ViewTreeObserver都可以监听什么回调?原理是什么? Q:你知道detachViewFromParent/attachViewToParent 这一组方法在哪些控件中被使用中？detachViewFromParent/attachViewToParent 与 removeView/addView 有什么区别呢？detachViewFromParent/attachViewToParent在什么场景下非常适合使用？ Q:requestLayout和invalidate的区别?都会执行到哪些生命周期? Q:view.requestLayout如果在灭屏或者切home之后调用会怎么样?  锁屏后，调用View.requestLayout()，会往上层层调用requestLayout()吗? 锁屏后，调用View.requestLayout()，会触发View的测量和布局操作吗？   Q:ViewStub是什么?有什么应用场景?原理是什么? Q:系统可以在子线程中访问UI吗？为什么这样设计? Q:为什么Toast和showDialog可以在子线程显示?需要做些什么? Q:View.post为何可以获取宽高信息? Q:View如何转换为Drawable?   Q:View.getContext()一定会返回activity对象吗?    并不是,有这么几种情况:
 View.inflate的时候手动传的不是activity 当使用AppCompatActivity时,context是TintWrapContext  Q:View.inflate和LayoutInflater.inflate方法区别？    View.inflate是对LayoutInflater的封装,其内部就是调用的LayoutInflater.inflate 创建view的方法是LayoutInflater的createViewFromTag方法。会依次调用mFactory2、mFactory和mPrivateFactory三者之一的onCreateView方法去创建一个View。如果不存在Factory，则调用LayoutInflater自身的onCreateView或者createView来实例化View</description>
    </item>
    
    <item>
      <title>二叉树</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>概述 二叉树的最近公共祖先  Q:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先   二叉树的最小深度  Q:给定一个二叉树，找出其最小深度     概述    二叉树主要考察满二叉树和完全二叉树,
 可以用来解决问题的方法:
 涉及到二叉树的构造:先序遍历 求普通二叉树的属性:后序遍历,单纯求深度就用前序 求二叉搜索树的属性:中序遍历 递归    确定递归函数的参数和返回值 确定终止条件 确定单层递归的逻辑    问题类型: 二叉树的最近公共祖先    Q:给定一个二叉树, 找到该树中两个指定节点的最近公共祖先    输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3   关键点
 递归   private boolean dfs(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return false;//定义出口  boolean lson = dfs(root.</description>
    </item>
    
    <item>
      <title>五大算法思想</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E4%BA%94%E5%A4%A7%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E4%BA%94%E5%A4%A7%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</guid>
      <description>分治法 动态规划   分治法    设计思想：将一个难以直接解决的大问题分解成规模较小的相同问题，以便分而治之。 实际的应用：快速排序、归并排序 分治法在每一层递归上的基本步骤： ①　分解：将原问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。 ②　解决：若子问题规模较小就直接解决，不然就递归解决各个子问题 ③　合并：将各个子问题的解合并为原问题的解
动态规划    动态规划法  设计思想：最优化原理，即一个过程的最优决策具有这样的性质：即无论其初始状态和初始决策如何，其今后诸策略对以第一个决策所形成的状态作为初始状态的过程而言，必须构成最优策略 动态规划法所要满足的条件： ①　问题中的状态满足最优化原理 ②　问题中的状态必须满足无后效性，无后效性指的是下一时刻的状态只与当前的状态 有关而与当前状态的之前状态无关。 动态规划三要素： ①　问题的阶段 ②　每个阶段的状态 ③　从前一个阶段转换到后一个阶段的递推关系 实际的应用：0/1背包问题 最长公共子串问题</description>
    </item>
    
    <item>
      <title>动态规划</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>概述 最长递增子序列  Q:给你一个整数数组 nums ，找到其中最长严格递增子序列的长度   零钱兑换 [真题]  Q:给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1   最长公共子序列 [真题]  Q:给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0   最大子序和 [真题]  Q:给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和   买卖股票 [真题]  Q:给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和     概述    正向递归,记录每一次执行的结果,用于下一次计算
 可以用来解决的问题:
 需要大量遍历寻找最优解 框架公式 单个数组或者字符串要用动态规划时，可以把动态规划 dp[i] 定义为 nums[0:i] 中想要求的结果 当两个数组或者字符串要用动态规划时，可以把动态规划定义成两维的 dp[i][j] ，其含义是在 A[0:i] 与 B[0:j] 之间匹配得到的想要的结果 1.</description>
    </item>
    
    <item>
      <title>哈希表</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <description>概述 有效的字母异位词  Q:给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词     概述    哈希表是根据关键码的值而直接进行访问的数据结构
 可以解决的问题类型:
 用来快速判断一个元素是否出现集合里   有效的字母异位词    Q:给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词    输入:s=&amp;quot;anagram&amp;quot; t=&amp;quot;nagaram&amp;quot; 输出:true   关键点
 数组其实就是一个简单哈希表 字符a到字符z的ASCII是26个连续的数值,可以用当前字母ASCII值减去‘a’的ASCII值作为数组下标   bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>图形系统</title>
      <link>https://gyzboy.github.io/interview/android/%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E5%9B%BE%E5%BD%A2%E7%B3%BB%E7%BB%9F/</guid>
      <description>Q:SurfaceFlinger是什么?有什么用? Q:什么是Surface? Q:Choreographer是什么?有什么用? Q:Choreographer是如何控制实现在下一个Vsync信号到来时实现View绘制的? Q:ViewRootImpl是如何实现从scheduleTraversals到performTraversals的? Q:Choreograhper是如何触发view绘制的? Q:Choreographer单例是怎么实现的？保存在哪里？ Q:ChoreoGrapher在初始化的时候,都做了什么? Q:一些QA Q:HWC是什么?有什么用? Q:Vsync信号是什么? Q:客户端是如何请求Vsync信号的?是合适触发的? Q:说说Android的多重缓冲? Q:如何设计一个双缓冲的view显示? Q:SurfaceTexture，TextureView, SurfaceView和GLSurfaceView？  SurfaceView: GLSurfaceView: SurfaceTexture: TextureView:     Q:SurfaceFlinger是什么?有什么用?    SurfaceFlinger负责合成所有的Layer并送显到Display,在Android系统中,SurfaceFlinger是一个独立进程
Q:什么是Surface?    Surface是一个窗口，例如：一个Activity是一个Surface、一个Dialog也是一个Surface，承载了上层的图形数据，与SurfaceFlinger侧的Layer相对应
Q:Choreographer是什么?有什么用?    在收到VSync pulse后，将马上开始下一帧的渲染。即一旦收到VSync通知，CPU和GPU就立刻开始计算然后把数据写入buffer。而这一&amp;quot;drawing with VSync&amp;quot; 的实现就是Choreographer
Q:Choreographer是如何控制实现在下一个Vsync信号到来时实现View绘制的?     所有UI的变化都是走到ViewRootImpl的scheduleTraversals()方法。 在VSync信号到来时才会执行绘制，即ViewRootImpl.performTraversals()  Q:ViewRootImpl是如何实现从scheduleTraversals到performTraversals的?     首先使用mTraversalScheduled字段保证同时间多次更改只会刷新一次，例如TextView连续两次setText()，也只会走一次绘制流程。 然后把当前线程的消息队列Queue添加了同步屏障，这样就屏蔽了正常的同步消息，保证VSync到来后立即执行绘制，而不是要等前面的同步消息。后面会具体分析同步屏障和异步消息的代码逻辑。 调用了mChoreographer.postCallback()方法，发送一个会在下一帧执行的回调，即在下一个VSync到来时会执行TraversalRunnable&amp;ndash;&amp;gt;doTraversal()&amp;mdash;&amp;gt;performTraversals()&amp;ndash;&amp;gt;绘制流程。  Q:Choreograhper是如何触发view绘制的?    Q:Choreographer单例是怎么实现的？保存在哪里？     在ViewRootImpl构造方法中获取了Choreographer实例 保持在了自己单例的ThreadLocal中  Q:ChoreoGrapher在初始化的时候,都做了什么?</description>
    </item>
    
    <item>
      <title>多线程</title>
      <link>https://gyzboy.github.io/interview/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>Q:什么是ThreadLocal?是如何实现的? Q:ThreadLocal是如何做到跟Thread绑定的? Q:ThreadLocal造成内存泄漏的原因?如何解决? Q:如何保证线程的处理是安全的? Q:JAVA中的锁有哪些处理方式？ Q:java虚拟机中对象头的锁结构是什么样的? Q:synchroinized是如何进行锁升级的? Q:线程的生命周期? Q:启动一个thread有哪几种方法?有什么区别? Q:yield和sleep有什么异同? Q:interrupted在阻塞态跟非阻塞态不同表现? Q:为什么不建议使用stop停止线程? Q:多线程三要素? Q:synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别？ Q:造成死锁的原因? Q:voliate原理? Q:CAS是什么?有什么问题？ Q:线程池原理?有几种运行状态? Q:Worker 的实现类，为什么不使用 ReentrantLock 来实现呢，而是自己继承AQS? Q:AQS锁有哪些?各有什么特点? Q:AQS如何实现的? Q:CountDownLactch与CyclicBarrier区别? Q:Java中锁的类型? Q:锁优化都有哪些? Q:Synchronized的优化   Q:什么是ThreadLocal?是如何实现的?    线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域 ThreadLocal的数据结构
//threadLocalHashCode的值是HASH_INCREMENT = 0x61c88647每次+1,取0x61c88647是因为这个值是黄金分割点 //每个线程有唯一的一个ThreadLocalMap,每个ThreadLocalMap中可以存放多个ThreadLocal对象 ThreadLocalMap(ThreadLocal firstKey, Object firstValue) { table = new Entry[INITIAL_CAPACITY]; //table是一个弱引用对象数组  //INITIAL_CAPACITY=16  int i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1);//有hash证明这是个采用哈希散列方式进行存储  table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);//设置扩容因子为len * 2 / 3 } cleanSomeSlots:启发式清理,试探的扫描一些单元格，寻找过期元素，也就是被垃圾回收的元素 expungeStaleEntry:探测式清理,是以当前遇到的 GC 元素开始，向后不断的清理。直到遇到 null 为止，才停止 rehash 计算</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://gyzboy.github.io/interview/java/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Q:字符编码 Q:Stirng不可变原因? Q:为什么要设计为不可变? Q:字符编码?   Q:字符编码     GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节  Q:Stirng不可变原因?     String主要的三个成员变量 char value[]， int offset, int count均是private，final的，并且没有对应的 getter/setter; String 对象一旦初始化完成，上述三个成员变量就不可修改；并且其所提供的接口任何对这些域的修改都将返回一个新对象； 技术博客大总结 是典型的 Immutable 类，被声明成为 final class，所有属性也都是final的。也由于它的不可变，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。  Q:为什么要设计为不可变?     可以缓存 hash 值 因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。 String Pool 的需要 如果一个String对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。 安全性 String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。 线程安全 String 不可变性天生具备线程安全，可以在多个线程中安全地使用。  Q:字符编码?</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>概述 替换空格  Q:把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;   重复串  Q:给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成   最长回文子串 (真题)  Q:你一个字符串 s，找到 s 中最长的回文子串。   最小覆盖子串(真题)  Q:给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &amp;quot;&amp;quot;     概述    字符串类类型的题目，往往想法比较简单，但是实现起来并不容易，复杂的字符串题目非常考验对代码的掌控能力
 可以用来解决问题的方法:
 双指针法 KMP算法(当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了)   替换空格    Q:把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;     输入：s = &amp;quot;We are happy.</description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://gyzboy.github.io/interview/java/%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/%E5%BC%82%E5%B8%B8/</guid>
      <description>Q:被检查的异常和不受检查的异常有什么区别? Q:异常处理的原理？ Q:try-finally-return执行顺序?   Q:被检查的异常和不受检查的异常有什么区别?     受检查异常  被检查的异常应该用try-catch块代码处理，或者在main方法中用throws关键字让JRE了解程序可能抛出哪些异常。 Exception是所有被检查异常的基类 被检查的异常适用于那些不是因程序引起的错误情况，比如：读取文件时文件不存在引发的FileNotFoundException   不受检查异常  不受检查的异常在程序中不要求被处理或用throws语句告知。 RuntimeException是所有不受检查异常的基类。 不被检查的异常通常都是由于糟糕的编程引起的，比如：在对象引用时没有确保对象非空而引起的NullPointerException    Q:异常处理的原理？    Java虚拟机用方法调用栈（method invocation stack）来跟踪每个线程中一系列的方法调用过程。如果在执行方法过程中抛出异常，则Java虚拟机必须找到能捕获该异常的catch代码块。当Java虚拟机追溯到调用栈的底部的方法的时候，如果仍然没有找到处理该异常的代码块，这样它就会按步骤处理，首先会打印方法调用栈的异常信息，然后如果所处的线程不是主线程，那么就会终止这个线程
Q:try-finally-return执行顺序?    public class TestReturn { public int test(){ int x = 1; try{ return ++x; } catch(Exception e){ }finally{ return ++x; } //return x;  } public static void main(String[] args){ TestReturn t = new TestReturn(); int result = t.</description>
    </item>
    
    <item>
      <title>性能优化</title>
      <link>https://gyzboy.github.io/interview/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</guid>
      <description>Q:常用内存命令有哪些? Q:启动优化?   Q:常用内存命令有哪些?     USS	Unique Set Size	物理内存	进程独占的内存 PSS	Proportional Set Size	物理内存	PSS= USS+ 按比例包含共享库 RSS	Resident Set Size	物理内存	RSS= USS+ 包含共享库 VSS	Virtual Set Size	虚拟内存	VSS= RSS+ 未分配实际物理内存   dumpsys meminfo //dumpsys meminfo &amp;ndash;package // 输出指定包名的进程，可能包含多个进程 适用场景： 查看进程的oom adj，或者dalvik/native等区域内存情况，或者某个进程或apk的内存情况，功能非常强大； procrank //适用场景： 查看进程的VSS/RSS/PSS/USS各个内存指标； cat /proc/meminfo //适用场景： 查看系统的详尽内存信息，包含内核情况； free //适用场景： 只查看系统的可用内存； showmap //适用场景： 查看进程的虚拟地址空间的内存分配情况； vmstat //适用场景： 周期性地打印出进程运行队列、系统切换、CPU时间占比等情况  Q:启动优化?</description>
    </item>
    
    <item>
      <title>排序</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</guid>
      <description>用最少数量的箭引爆气球  Q:找边界射爆气球   合并边界  Q:以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间   经典排序  冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 堆排序     用最少数量的箭引爆气球    Q:找边界射爆气球    输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2   关键点
 排序,找右边界 贪心   public int findMinArrowShots(int[][] points) { if (points.length == 0) { return 0; } Arrays.sort(points, new Comparator&amp;lt;int[]&amp;gt;() { public int compare(int[] point1, int[] point2) { if (point1[1] &amp;gt; point2[1]) { return 1; } else if (point1[1] &amp;lt; point2[1]) { return -1; } else { return 0; } } }); //[[1,6],[2,8],[7,12],[10,16]]  int pos = points[0][1]; int ans = 1; for (int[] balloon: points) { if (balloon[0] &amp;gt; pos) {//不断改变右边界  pos = balloon[1]; ++ans; } } return ans; } 合并边界    Q:以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间    输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]]   关键点</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</guid>
      <description>概述 有序数组索引  Q:从排序数组中找到目标值并返回其索引   原地删除元素  Q:给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度?   最小子串  Q:给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0   俄罗斯套娃(真题)  Q:给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）   最长连续递增序列  Q:给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。   盛最多水的容器(真题)  Q:给你 n 个非负整数 a1，a2，&amp;hellip;，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。   接雨水问题(真题)  Q:给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水   和为K的子数组  Q:给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数     概述    数组是存放在连续内存空间上的相同类型数据的集合</description>
    </item>
    
    <item>
      <title>注解</title>
      <link>https://gyzboy.github.io/interview/android/%E6%B3%A8%E8%A7%A3/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E6%B3%A8%E8%A7%A3/</guid>
      <description>Q:Android中提供了哪些与线程相关的注解? Q:抽象处理器中四个方法有何作用？annotationProcessor和apt区别？   Q:介绍下ASM?  ClassVisitor ClassReader ClassWriter MethodVisitor &amp;amp; AdviceAdapter FieldVisitor   Q:ASM的开发流程?   Q:Android中提供了哪些与线程相关的注解?     @UiThread,通常可以等同于主线程,标注方法需要在UIThread执行,比如View类就使用这个注解 @MainThread 主线程,经常启动后创建的第一个线程 @WorkerThread 工作者线程,一般为一些后台的线程,比如AsyncTask里面的doInBackground就是这样的 @BinderThread 注解方法必须要在BinderThread线程中执行,一般使用较少  Q:抽象处理器中四个方法有何作用？annotationProcessor和apt区别？      抽象处理器中四个方法有何作用
 init(ProcessingEnvironment processingEnvironment): 每一个注解处理器类都必须有一个空的构造函数。然而，这里有一个特殊的init()方法，它会被注解处理工具调用，并输入ProcessingEnviroment参数。ProcessingEnviroment提供很多有用的工具类Elements,Types和Filer。后面我们将看到详细的内容。 process(Set&amp;lt;? extends TypeElement&amp;gt; set, RoundEnvironment roundEnvironment): 这相当于每个处理器的主函数main()。你在这里写你的扫描、评估和处理注解的代码，以及生成Java文件。输入参数RoundEnviroment，可以让你查询出包含特定注解的被注解元素。后面我们将看到详细的内容。 getSupportedAnnotationTypes(): 这里你必须指定，这个注解处理器是注册给哪个注解的。注意，它的返回值是一个字符串的集合，包含本处理器想要处理的注解类型的合法全称。换句话说，你在这里定义你的注解处理器注册到哪些注解上。 getSupportedSourceVersion(): 用来指定你使用的Java版本。通常这里返回SourceVersion.latestSupported()。然而，如果你有足够的理由只支持Java 7的话，你也可以返回SourceVersion.RELEASE_7    annotationProcessor和apt区别？
 Android 官方的 annotationProcessor 同时支持 javac 和 jack 编译方式，而 android-apt 只支持 javac 方式。当然，目前 android-apt 在 Android Gradle 插件 2.</description>
    </item>
    
    <item>
      <title>消息通信</title>
      <link>https://gyzboy.github.io/interview/android/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E6%B6%88%E6%81%AF%E9%80%9A%E4%BF%A1/</guid>
      <description>Q:Linux都有哪些进程间通信方式（IPC）？Android呢? Q:什么是Binder?为什么使用Binder作为Android IPC？ Q:Intent是如何进行进程间通信的? Q:什么是mmap? Q:为什么有共享内存了还需要设计Binder? Q:ServiceManager启动流程? Q:Binder线程池? Q:Binder创建的内核内存大小? Q:Binder进程与线程? Q:系统服务与bindService等启动的服务的区别? Q:Binder请求的同步与异步? Q:如果有多个进程向用一个Server服务发出Binder请求处理?会发生什么? Q:Binder是如何进行权限控制的? Q:什么情况下会触发Binder的linkToDeath?如何触发? Q:Android中哪些IPC用到了Socket,为什么? Q:Handler是什么? Q:Handler机制主要包含什么?各自用途是什么? Q:Looper.prepare可以多次调用吗?为什么? Q:Handler中消息分发顺序? Q:Handle中有几种消息类型? Q:用过Message的setAsynchronous吗?有什么用? Q:Looper 死循环为什么不会导致应用卡死，会消耗大量资源吗？ Q:主线程的Handler是在ActivityThread中启动的,那么他是一个线程吗?不是的话,那么主线程所依附的线程是什么? Q:为什么handler会造成内存泄漏?如何处理? Q:handler的postDelay是如何实现的?   Q:Linux都有哪些进程间通信方式（IPC）？Android呢?    Linux:
 管道：在创建时分配一个page大小的内存，缓存区大小比较有限； 消息队列：信息复制两次，额外的CPU消耗；不合适频繁或信息量大的通信； 共享内存：无须复制，共享缓冲区直接付附加到进程虚拟地址空间，速度快；但进程间的同步问题操作系统无法实现，必须各进程利用同步工具解决； 套接字：作为更通用的接口，传输效率低，主要用于不通机器或跨网络的通信； 信号量：常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 信号: 不适用于信息交换，更适用于进程中断控制，比如非法内存访问，杀死某个进程等； Android: Binder Socket Handler  Q:什么是Binder?为什么使用Binder作为Android IPC？     使用mmap只拷贝一次内存使Binder变的高效  binder_mmap通过加锁，保证一次只有一个进程分配内存，保证多进程间的并发访问。 虚拟进程地址空间(vm_area_struct)和虚拟内核地址空间(vm_struct)都映射到同一块物理内存空间。当Client端与Server端发送数据时，Client（作为数据发送端）先从自己的进程空间把IPC通信数据copy_from_user拷贝到内核空间，而Server端（作为数据接收端）与内核共享数据，不再需要拷贝数据，而是通过内存地址空间的偏移量，即可获悉内存地址，整个过程只发生一次内存拷贝  Q:Intent是如何进行进程间通信的?    Q:什么是mmap?    mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系
Q:为什么有共享内存了还需要设计Binder?    共享内存实现方式复杂，没有客户与服务端之别， 需要充分考虑到访问临界资源的并发同步问题，否则可能会出现死锁等问题；从这稳定性角度看，Binder架构优越于共享内存</description>
    </item>
    
    <item>
      <title>算法模板</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</guid>
      <description>二分查找法 KMP 二叉树  树的遍历 二叉树深度 二叉树节点数量   回溯算法 并查集   二分查找法    class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int n = nums.size(); int left = 0; int right = n; // 我们定义target在左闭右开的区间里，[left, right) while (left &amp;lt; right) { // 因为left == right的时候，在[left, right)是无效的空间 int middle = left + ((right - left) &amp;gt;&amp;gt; 1); if (nums[middle] &amp;gt; target) { right = middle; // target 在左区间，因为是左闭右开的区间，nums[middle]一定不是我们的目标值，所以right = middle，在[left, middle)中继续寻找目标值 } else if (nums[middle] &amp;lt; target) { left = middle + 1; // target 在右区间，在 [middle+1, right)中 } else { // nums[middle] == target return middle; // 数组中找到目标值的情况，直接返回下标 } } return right; } }; KMP    void kmp(int* next, const string&amp;amp; s){ next[0] = -1; int j = -1; for(int i = 1; i &amp;lt; s.</description>
    </item>
    
    <item>
      <title>组件化</title>
      <link>https://gyzboy.github.io/interview/android/%E7%BB%84%E4%BB%B6%E5%8C%96/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E7%BB%84%E4%BB%B6%E5%8C%96/</guid>
      <description>Q:组件化与模块化区别? Q:业务组件，如何实现单独运行调试？ Q:业务组件间 没有依赖，如何实现页面的跳转？ Q:业务组件间 没有依赖，如何实现组件间通信/方法调用？ Q:业务组件不能反向依赖壳工程，如何获取Application实例、如何获取Application onCreate()回调（用于任务初始化）？ Q:如何实现一个路由框架?   Q:组件化与模块化区别?     组件化:组件化，去除模块间的耦合，使得每个业务模块可以独立当做App存在，对于其他模块没有直接的依赖关系 模块化:模块化就是拆分成多个模块放在不同的Module里面，每个功能的代码都在自己所属的 module 中添加  Q:业务组件，如何实现单独运行调试？     单工程方案，组件以module形式存在，动态配置组件的工程类型；  动态修改gradle文件,集成时变为Library插件,独立调试时变为Application插件 动态配置ApplicationId 和 AndroidManifest   多工程方案，业务组件以library module形式存在于独立的工程，且只有这一个library module。  业务组件以library module形式存在于独立的工程 发布到Maven仓库,通过引入第三方依赖方式使用    Q:业务组件间 没有依赖，如何实现页面的跳转？    使用路由
Q:业务组件间 没有依赖，如何实现组件间通信/方法调用？     服务暴露组件  Q:业务组件不能反向依赖壳工程，如何获取Application实例、如何获取Application onCreate()回调（用于任务初始化）？    通过AppLifeCycle回调
Q:如何实现一个路由框架?     不使用注解器  手动把每个界面和相应的Activity对应起来。这个处理过程可以在Application里面做的  routers.</description>
    </item>
    
    <item>
      <title>网络</title>
      <link>https://gyzboy.github.io/interview/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C/</guid>
      <description>Q:GET 和 POST 的区别，你知道哪些？ Q:一个TCP连接可以对应几个HTTP请求？ Q:在浏览器中输入url地址后显示主页的过程? Q:DNS解析过程? Q:HTTP中有个缓存机制，但如何保证缓存是最新的呢？ Q:三次握手过程中可以携带数据吗？ Q:挥手为什么需要四次? Q:非对称密钥加密你了解吗？优缺点？ Q:HTTPS采用的加密方式有哪些？是对称还是非对称？ Q:TCP四大拥塞控制算法总结？（极其重要）  慢热启动算法 – Slow Start 拥塞避免算法 – Congestion Avoidance 拥塞发生状态时的算法 快速恢复算法 – Fast Recovery   Q:你了解流量控制原理吗？ Q:TCP 协议如何保证可靠传输？ Q:TCP 利用滑动窗口实现流量控制的机制？ Q:常见的HTTP状态码有哪些？  1xx 信息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误     Q:GET 和 POST 的区别，你知道哪些？     get是获取数据，post是修改数据 get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（requrest body） get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET请求会被浏览器主动缓存，而POST不会，除非手动设置。  Q:一个TCP连接可以对应几个HTTP请求？    如果维持连接，一个 TCP 连接是可以发送多个 HTTP 请求的</description>
    </item>
    
    <item>
      <title>设计模式</title>
      <link>https://gyzboy.github.io/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
      <description>概述 创建型  单例（Singleton） 简单工厂（Simple Factory） Implementation 工厂方法（Factory Method） Implementation 抽象工厂（Abstract Factory） Implementation 生成器（Builder） 原型模式（Prototype）   行为型  责任链（Chain Of Responsibility） 命令（Command） 解释器（Interpreter） 迭代器（Iterator） 中介者（Mediator） 备忘录（Memento） 观察者（Observer） 状态（State） 策略（Strategy） 模板方法（Template Method） 访问者（Visitor） 空对象（Null）   结构型  适配器（Adapter） 桥接（Bridge） 组合（Composite） 装饰（Decorator） 外观（Facade） 享元（Flyweight） 代理（Proxy）     概述    设计模式是解决问题的方案，学习现有的设计模式可以做到经验复用。
拥有设计模式词汇，在沟通时就能用更少的词汇来讨论，并且不需要了解底层细节。
创建型    单例（Singleton）    Intent    确保一个类只有一个实例，并提供该实例的全局访问点。</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</guid>
      <description>概述 删除给定值的节点  Q:删除链表中等于给定值 val 的所有节点   反转链表  Q:反转一个单链表   删除倒数第k个节点  Q:给定一链表,删除倒数第K个节点   环形链表  Q:给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null   是否是回文链表  Q:判断一个链表是否为回文链表   合并链表  Q:合并K个有序链表   找交点  Q:找到两个单链表相交的起始节点     概述    链表的种类主要为：单链表，双链表，循环链表,链表的节点在内存中是分散存储的，通过指针连在一起
 可以用来解决问题的方法:
 虚拟头结点 双指针 分治法   删除给定值的节点    Q:删除链表中等于给定值 val 的所有节点    输入:1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6,val=6 输出:1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5   关键点</description>
    </item>
    
    <item>
      <title>集合</title>
      <link>https://gyzboy.github.io/interview/java/%E9%9B%86%E5%90%88/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/java/%E9%9B%86%E5%90%88/</guid>
      <description>HashMap:  Q:准备用HashMap存1w条数据，构造时传10000还会触发扩容吗？ Q:扰动函数是什么?有什么用? Q:HashMap中的初始化容量,如果传入17,最初的大小是多少? Q:HashMap的数据存储? Q:HashMap.put数据是怎么样的?需要注意些什么? Q:HashMap中红黑树是怎么实现新增的? Q:链表转红黑树定义的长度为什么是8？ Q:HashMap为什么每次都是以 2的幂次方扩容？ Q:HashMap是如何进行resize操作的? Q:HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？   ArrayList:  Q:ArrayList解析?   CopyOnWriteArrayList:  Q:CopyOnWriteArrayList是如何保证线程安全的? Q:CopyOnWriteArraylist中已经有互斥锁了,为什么还需要copy数据?   ConcurrentHashMap:  Q:ConcurrentHashMap是如何保证线程安全的?   LinkedHashMap:  Q:LinkedHashMap是如何实现LRU的?   队列  Q:队列的存取 API 都有什么区别？比如 put take 和 offer poll? Q:ArrayBlockingQueue有什么特点? Q:哪些队列有阻塞功能?是如何实现的? Q:假设 SynchronousQueue 底层使用的是堆栈，线程 1 执行 take 操作阻塞住了，然后有线程 2 执行 put 操作，问此时线程 2 是如何把 put 的数据传递给 take 的？   Q:描述下ArrayMap? Q:TreeMap 的内部是怎么排序的?</description>
    </item>
    
    <item>
      <title></title>
      <link>https://gyzboy.github.io/interview/android/%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gyzboy.github.io/interview/android/%E5%8A%A8%E7%94%BB/</guid>
      <description>Q:View动画为何不能真正改变View的位置？而属性动画为何可以？属性动画是如何改变View的属性？    Q:属性动画插值器和估值器的作用？插值器和估值器分别是如何更改动画的？    </description>
    </item>
    
  </channel>
</rss>
