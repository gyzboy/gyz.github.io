<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on gyzboy的十万个为什么</title>
    <link>https://gyzboy.github.io/interview/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on gyzboy的十万个为什么</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Apr 2021 16:12:16 +0800</lastBuildDate><atom:link href="https://gyzboy.github.io/interview/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;基础知识</title>
      <link>https://gyzboy.github.io/interview/c&#43;&#43;/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/c&#43;&#43;/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
      <description>什么是命名空间? 带默认形参的函数 函数模板 内联函数 类的定义 对象的建立和使用 对象创建 对象指针 对象引用 友元函数 虚基类和虚基类的使用 虚函数 文件读写 智能指针 什么是命名空间? using namespace std;
类似于java中的包名,主要是为了解决多个模块间命名出冲突的问题
带默认形参的函数 int add(int a =4,int b =5){ return a+b; } cout &amp;lt;&amp;lt; add() &amp;lt;&amp;lt; endl; //9 函数模板 C++和java一样都有函数的重载，函数重载可以处理多种类型，同一个方法名，但依然需要分开定义，如果可以让他代码更精简一点，模板化就更好了,为此C++提供了函数模板这一机制，可以大大提高函数的通用性(自我感觉像泛型)
template&amp;lt;class 类型名1，class 类型名2…&amp;gt; 返回值 函数名（形参表列） 模板参数表 { 函数体 } 内联函数 通过在函数上添加inline关键字,在编译的时候，把函数代码插入到函数调用的地方， 就像普通的程序执行代码一样
类的定义 class Sts{ public://访问修饰符跟java类似 int a; char name[100]; int socre; int print(); };//注意这个分号 int Sts::print(){//在类外定义函数体，在类外定义函数体的需要类名加上::域限定符 cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&amp;#34;/&amp;#34;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;&amp;#34;/&amp;#34;&amp;lt;&amp;lt;socre&amp;lt;&amp;lt;endl; return 0; } 对象的建立和使用 对象创建 int *a= new int;//动态分配一个int类型的内存空间； delete a;//释放内存； //分配10个int数据空间 int *aa= new int[10]; delete []aa; 对象指针 Sts *p; Sts s; s.</description>
    </item>
    
  </channel>
</rss>
