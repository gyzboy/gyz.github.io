<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 十万个为什么</title>
    <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 十万个为什么</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 Apr 2021 16:12:16 +0800</lastBuildDate><atom:link href="https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>双指针</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/</guid>
      <description>  </description>
    </item>
    
    <item>
      <title>哈希表</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid>
      <description>有效的字母异位词  Q:给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词     有效的字母异位词    Q:给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词    输入:s=&amp;quot;anagram&amp;quot; t=&amp;quot;nagaram&amp;quot; 输出:true   关键点
 数组其实就是一个简单哈希表 字符a到字符z的ASCII是26个连续的数值,可以用当前字母ASCII值减去‘a’的ASCII值作为数组下标   bool isAnagram(string s, string t) { int record[26] = {0}; for (int i = 0; i &amp;lt; s.size(); i++) { // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了  record[s[i] - &amp;#39;a&amp;#39;]++; } for (int i = 0; i &amp;lt; t.</description>
    </item>
    
    <item>
      <title>字符串</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>替换空格  Q:把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;   重复串  Q:给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成     替换空格    Q:把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;     输入：s = &amp;quot;We are happy.&amp;quot; 输出：&amp;quot;We%20are%20happy.&amp;quot;   关键点:
 双指针 从后向前遍历避免每次添加元素后移动元素   string replaceSpace(string s) { int count = 0; // 统计空格的个数  int sOldSize = s.size(); for (int i = 0; i &amp;lt; s.size(); i++) { if (s[i] == &amp;#39; &amp;#39;) { count++; } } // 扩充字符串s的大小，也就是每个空格替换成&amp;#34;%20&amp;#34;之后的大小  s.</description>
    </item>
    
    <item>
      <title>数组</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84/</guid>
      <description>有序数组索引  Q:从排序数组中找到目标值并返回其索引   原地删除元素  Q:给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度?   最小子串  Q:给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0     有序数组索引    Q:从排序数组中找到目标值并返回其索引     输入: [1,3,5,6], 5 输出: 2   关键点:
 有序数组 边界处理   int searchInsert1(int[] nums, int target) { int n = nums.length(); int left = 0; int right = n - 1; // 定义target在左闭右闭的区间里，[left, right]  while (left &amp;lt;= right) { // 当left==right，区间[left, right]依然有效  int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2  if (nums[middle] &amp;gt; target) { right = middle - 1; // target 在左区间，所以[left, middle - 1]  } else if (nums[middle] &amp;lt; target) { left = middle + 1; // target 在右区间，所以[middle + 1, right]  } else { // nums[middle] == target  return middle; } } // 分别处理如下四种情况  // 目标值在数组所有元素之前 [0, -1]  // 目标值等于数组中某一个元素 return middle;  // 目标值插入数组中的位置 [left, right]，return right + 1  // 目标值在数组所有元素之后的情况 [left, right]， return right + 1  return right + 1; int searchInsert2(int[] nums, int target) { int n = nums.</description>
    </item>
    
    <item>
      <title>链表</title>
      <link>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 13 Apr 2021 16:12:16 +0800</pubDate>
      
      <guid>https://gyzboy.github.io/interview/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/</guid>
      <description>删除给定值的节点  Q:删除链表中等于给定值 val 的所有节点   反转链表  Q:反转一个单链表   删除倒数第k个节点  Q:给定一链表,删除倒数第K个节点   环形链表  Q:给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null     删除给定值的节点    Q:删除链表中等于给定值 val 的所有节点    输入:1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6,val=6 输出:1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5   关键点
 创建虚拟头结点,用来删除第一个元素   ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点  dummyHead-&amp;gt;next = head; // 将虚拟头结点指向head，这样方面后面做删除操作  ListNode* cur = dummyHead; while (cur-&amp;gt;next !</description>
    </item>
    
  </channel>
</rss>
